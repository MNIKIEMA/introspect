// this "analysis agent" will contain a similar view to the agent for report creation.
// just without the report display.
// we will reuse the code and endpoints of the report to generate "Sections" instead of full reports.
// when we finally get the report sections/text, we will add them to the content array of the block in the blocknote editor.
// The text generated by the model will only be useful on the initial render.
// Any edits after that will be stored in blocknote's editor state.
// of course, all of the content will be emptied out if the text of this "block/section/sections" is regenerated.

import { message } from "antd";
import React, {
  useEffect,
  useRef,
  useState,
  Fragment,
  useContext,
  useCallback,
  useMemo,
  useSyncExternalStore,
} from "react";
import { ThemeContext, lightThemeColor } from "../../context/ThemeContext";
import AgentLoader from "../common/AgentLoader";
import Lottie from "lottie-react";
import LoadingLottie from "../svg/loader.json";
import { DocContext } from "../../../docs/DocContext";
import { ToolResults } from "./ToolResults";
import StepsDag from "../common/StepsDag";
import ErrorBoundary from "../common/ErrorBoundary";
import { Context } from "../../../../components/common/Context";
import { toolShortNames } from "../../../../utils/utils";
import { ReactiveVariablesContext } from "../../../docs/ReactiveVariablesContext";
import Input from "antd/es/input";
import TextArea from "antd/es/input/TextArea";
import Clarify from "./analysis-gen/Clarify";
import AnalysisManager from "./analysisManager";

const { Search } = Input;

// the name of the prop where the data is stored for each stage
const propNames = {
  clarify: "clarification_questions",
  gen_approaches: "approaches",
  gen_steps: "steps",
  gen_report: "report_sections",
};

const agentRequestTypes = ["clarify", "gen_steps"];

export const AnalysisAgent = ({
  analysisId,
  username,
  updateHook = () => {},
  editor,
  block,
  createAnalysisRequestBody = {},
  initiateAutoSubmit = false,
  searchRef,
  setGlobalLoading,
}) => {
  const [pendingToolRunUpdates, setPendingToolRunUpdates] = useState({});
  const [reRunningSteps, setRerunningSteps] = useState([]);
  const reactiveContext = useContext(ReactiveVariablesContext);
  const [context, setContext] = useContext(Context);
  const { user } = context;
  const [activeNode, setActiveNodePrivate] = useState(null);
  const [dag, setDag] = useState(null);
  const [dagLinks, setDagLinks] = useState([]);

  const [toolRunDataCache, setToolRunDataCache] = useState({});

  const docContext = useContext(DocContext);

  const { mainManager, reRunManager, toolSocketManager } =
    docContext.val.socketManagers;

  function onMainSocketMessage(response, newAnalysisData) {
    try {
      setToolRunDataCache(analysisManager.toolRunDataCache);

      console.log("onMainSocketMessage", response);

      if (response && response?.done) {
        setAnalysisBusy(false);
      }

      if (!newAnalysisData) return;
      // if current stage is clarify
      // but clarification steps length is 0
      // submit again
      if (
        newAnalysisData.currentStage === "clarify" &&
        !newAnalysisData?.clarify?.clarification_questions?.length
      ) {
        handleSubmit(null, { clarification_questions: [] }, null);
      }
    } catch (e) {
      message.error(e);
      setAnalysisBusy(false);
    }
  }

  async function onReRunMessage(response, newAnalysisData) {
    try {
      setRerunningSteps(analysisManager.reRunningSteps);
      // remove all pending updates for this tool_run_id
      // because all new data is already there in the received response
      setPendingToolRunUpdates((prev) => {
        const newUpdates = { ...prev };
        delete newUpdates[response.tool_run_id];
        return newUpdates;
      });

      setToolRunDataCache(analysisManager.toolRunDataCache);

      // update reactive context
      Object.keys(response?.tool_run_data?.outputs || {}).forEach((k, i) => {
        if (!response?.tool_run_data?.outputs?.[k]?.reactive_vars) return;
        const runId = response.tool_run_id;
        reactiveContext.update((prev) => {
          return {
            ...prev,
            [runId]: {
              ...prev[runId],
              [k]: response?.tool_run_data?.outputs?.[k]?.reactive_vars,
            },
          };
        });
      });
    } catch (e) {
      message.error(e);
    } finally {
      setAnalysisBusy(false);
    }
  }

  const analysisManager = useMemo(() => {
    const mgr = AnalysisManager({
      analysisId,
      mainSocket: mainManager,
      rerunSocket: reRunManager,
      onNewData: onMainSocketMessage,
      onReRunData: onReRunMessage,
      username,
      userEmail: user,
      createAnalysisRequestBody,
      initiateAutoSubmit,
    });
    return mgr;
  }, [
    analysisId,
    mainManager,
    reRunManager,
    username,
    createAnalysisRequestBody,
  ]);

  const [analysisBusy, setAnalysisBusy] = useState(initiateAutoSubmit);

  const analysisData = useSyncExternalStore(
    analysisManager.subscribeToDataChanges,
    analysisManager.getAnalysisData
  );

  function setActiveNode(node) {
    setActiveNodePrivate(node);
    // if update_prop is "sql" or "code_str" or "analysis", update tool_run_details
    // if update_prop is inputs, update step.inputs
    // update in context
    Object.keys(pendingToolRunUpdates).forEach((toolRunId) => {
      const updateProps = Object.keys(pendingToolRunUpdates[toolRunId]);
      const toolRunData = toolRunDataCache[toolRunId]?.tool_run_data;
      if (!toolRunData) return;

      updateProps.forEach((updateProp) => {
        if (updateProp === "sql" || updateProp === "code_str") {
          // update tool_run_details
          toolRunData.tool_run_details[updateProp] =
            pendingToolRunUpdates[toolRunId][updateProp];
        } else if (updateProp === "inputs") {
          // update step.inputs
          toolRunData.step.inputs =
            pendingToolRunUpdates[toolRunId][updateProp];
        }
      });
      toolRunData.edited = true;

      // update the cache
      setToolRunDataCache((prev) => {
        return {
          ...prev,
          [toolRunId]: {
            ...prev[toolRunId],
            tool_run_data: toolRunData,
          },
        };
      });
    });

    setPendingToolRunUpdates({});
  }

  useEffect(() => {
    async function initialiseAnalysis() {
      try {
        await analysisManager.init();

        if (analysisManager.wasNewAnalysisCreated) {
          // also have to set docContext in this case
          docContext.update({
            ...docContext.val,
            userItems: {
              ...docContext.val.userItems,
              analyses: [...docContext.val.userItems.analyses, analysisId],
            },
          });
        }

        if (
          initiateAutoSubmit &&
          !analysisManager?.analysisData?.currentStage
        ) {
          handleSubmit(null, {}, null);
        }
      } catch (e) {
        console.log(e);
      }
    }
    initialiseAnalysis();
  }, []);

  useEffect(() => {
    if (!analysisManager) return;

    analysisManager.setMainSocket(mainManager);
    analysisManager.setReRunSocket(reRunManager);

    analysisManager.addEventListeners();

    return () => {
      analysisManager.removeEventListeners();
    };
  }, [analysisManager, mainManager, reRunManager]);

  const handleSubmit = useCallback(
    (ev, stageInput = {}, submitSourceStage = null) => {
      try {
        const query = searchRef.current.input.value;
        analysisManager.submit(ev, query, stageInput, submitSourceStage);
        setAnalysisBusy(true);
      } catch (err) {
        message.error(err);
        setAnalysisBusy(false);
      }
    },
    [analysisManager, searchRef]
  );

  const handleReRun = useCallback(
    (toolRunId, preRunActions = {}) => {
      if (
        !toolRunId ||
        !dag ||
        !analysisId ||
        !reRunManager ||
        !reRunManager.send ||
        !activeNode
      ) {
        console.log(toolRunId, dag, analysisId, reRunManager, activeNode);
        return;
      }

      try {
        analysisManager.initiateReRun(toolRunId, preRunActions);
      } catch (e) {
        console.log(e);
        message.error(err);
      }
    },
    [analysisId, activeNode, reRunManager, dag, analysisManager]
  );

  return (
    <ErrorBoundary>
      <div className="analysis-agent-container">
        <ThemeContext.Provider
          value={{ theme: { type: "light", config: lightThemeColor } }}
          key="1"
        >
          {!analysisData ? (
            <div className="analysis-data-loader">
              <AgentLoader
                message={"Setting up..."}
                lottie={<Lottie animationData={LoadingLottie} loop={true} />}
              />
            </div>
          ) : (
            <div className="analysis-ctr">
              {analysisData.currentStage === "clarify" && (
                <div className="analysis-recipe">
                  <Clarify
                    data={analysisData.clarify}
                    handleSubmit={handleSubmit}
                    globalLoading={analysisBusy}
                    stageDone={
                      analysisData.currentStage === "clarify"
                        ? !analysisBusy
                        : true
                    }
                    isCurrentStage={analysisData.currentStage === "clarify"}
                  />
                </div>
              )}

              {analysisData.currentStage === "gen_steps" && (
                <div className="analysis-content">
                  <div className="analysis-results">
                    <ErrorBoundary>
                      {analysisData?.gen_steps?.steps.length ? (
                        <ToolResults
                          analysisId={analysisId}
                          activeNode={activeNode}
                          analysisData={analysisData}
                          toolSocketManager={toolSocketManager}
                          dag={dag}
                          setActiveNode={setActiveNode}
                          handleReRun={handleReRun}
                          reRunningSteps={reRunningSteps}
                          setPendingToolRunUpdates={setPendingToolRunUpdates}
                          toolRunDataCache={toolRunDataCache}
                          setToolRunDataCache={setToolRunDataCache}
                        ></ToolResults>
                      ) : (
                        analysisBusy && (
                          <AgentLoader
                            message={"Running analysis..."}
                            lottie={
                              <Lottie
                                animationData={LoadingLottie}
                                loop={true}
                              />
                            }
                          />
                        )
                      )}
                    </ErrorBoundary>
                  </div>
                  <div className="analysis-steps">
                    <StepsDag
                      steps={analysisData?.gen_steps?.steps || []}
                      nodeSize={[40, 10]}
                      nodeGap={[30, 50]}
                      setActiveNode={setActiveNode}
                      reRunningSteps={reRunningSteps}
                      activeNode={activeNode}
                      stageDone={
                        analysisData.currentStage === "gen_steps"
                          ? !analysisBusy
                          : true
                      }
                      dag={dag}
                      setDag={setDag}
                      dagLinks={dagLinks}
                      setDagLinks={setDagLinks}
                      extraNodeClasses={(node) => {
                        return node.data.isTool
                          ? `rounded-md px-1 text-center`
                          : "";
                      }}
                      toolIcon={(node) => (
                        <p className="text-sm truncate m-0">
                          {toolShortNames[node?.data?.step?.tool_name] ||
                            "Unknown tool"}
                        </p>
                      )}
                    />
                  </div>
                </div>
              )}
            </div>
          )}
        </ThemeContext.Provider>
      </div>
    </ErrorBoundary>
  );
};
