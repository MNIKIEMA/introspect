// this "analysis agent" will contain a similar view to the agent for report creation.
// just without the report display.
// we will reuse the code and endpoints of the report to generate "Sections" instead of full reports.
// when we finally get the report sections/text, we will add them to the content array of the block in the blocknote editor.
// The text generated by the model will only be useful on the initial render.
// Any edits after that will be stored in blocknote's editor state.
// of course, all of the content will be emptied out if the text of this "block/section/sections" is regenerated.

import { message } from "antd";
import React, {
  useEffect,
  useRef,
  useState,
  Fragment,
  useContext,
  useCallback,
  useMemo,
} from "react";
import { ThemeContext, lightThemeColor } from "../../context/ThemeContext";
import AgentLoader from "../common/AgentLoader";
import Lottie from "lottie-react";
import LoadingLottie from "../svg/loader.json";
import { DocContext } from "../../../docs/DocContext";
import { ToolResults } from "./ToolResults";
import StepsDag from "../common/StepsDag";
import ErrorBoundary from "../common/ErrorBoundary";
import { Context } from "../../../../components/common/Context";
import { toolShortNames } from "../../../../utils/utils";
import { ReactiveVariablesContext } from "../../../docs/ReactiveVariablesContext";
import Input from "antd/es/input";
import TextArea from "antd/es/input/TextArea";
import Clarify from "./analysis-gen/Clarify";
import AnalysisManager from "./analysisManager";

const { Search } = Input;

// the name of the prop where the data is stored for each stage
const propNames = {
  clarify: "clarification_questions",
  gen_approaches: "approaches",
  gen_steps: "steps",
  gen_report: "report_sections",
};

const agentRequestTypes = ["clarify", "gen_steps"];

export const AnalysisAgent = ({
  analysisId,
  username,
  updateHook = () => {},
  editor,
  block,
  createAnalysisRequestBody = {},
  initiateAutoSubmit = false,
  searchRef,
  setGlobalLoading,
}) => {
  const [analysisData, setAnalysisData] = useState(null);
  const [analysisSteps, setAnalysisSteps] = useState([]);
  const [pendingToolRunUpdates, setPendingToolRunUpdates] = useState({});
  const [reRunningSteps, setRerunningSteps] = useState([]);
  const reactiveContext = useContext(ReactiveVariablesContext);

  const [analysisTitle, setAnalysisTitle] = useState();
  const [context, setContext] = useContext(Context);
  const { user } = context;
  const [activeNode, setActiveNodePrivate] = useState(null);
  const [dag, setDag] = useState(null);
  const [dagLinks, setDagLinks] = useState([]);

  const [toolRunDataCache, setToolRunDataCache] = useState({});
  const [analysisBusy, _setAnalysisBusy] = useState(false);
  const setAnalysisBusy = (v) => {
    _setAnalysisBusy(v);
    setGlobalLoading(v);
  };

  const [currentStage, setCurrentStage] = useState(null);
  const [stageDone, setStageDone] = useState(true);
  const docContext = useContext(DocContext);

  const { mainManager, reRunManager, toolSocketManager } =
    docContext.val.socketManagers;

  function setActiveNode(node) {
    setActiveNodePrivate(node);
    // if update_prop is "sql" or "code_str" or "analysis", update tool_run_details
    // if update_prop is inputs, update step.inputs
    // update in context
    Object.keys(pendingToolRunUpdates).forEach((toolRunId) => {
      const updateProps = Object.keys(pendingToolRunUpdates[toolRunId]);
      const toolRunData = toolRunDataCache[toolRunId]?.tool_run_data;
      if (!toolRunData) return;

      updateProps.forEach((updateProp) => {
        if (updateProp === "sql" || updateProp === "code_str") {
          // update tool_run_details
          toolRunData.tool_run_details[updateProp] =
            pendingToolRunUpdates[toolRunId][updateProp];
        } else if (updateProp === "inputs") {
          // update step.inputs
          toolRunData.step.inputs =
            pendingToolRunUpdates[toolRunId][updateProp];
        }
      });
      toolRunData.edited = true;

      // update the cache
      setToolRunDataCache((prev) => {
        return {
          ...prev,
          [toolRunId]: {
            ...prev[toolRunId],
            tool_run_data: toolRunData,
          },
        };
      });
    });

    setPendingToolRunUpdates({});
  }

  useEffect(() => {
    if (analysisData?.gen_steps?.success && analysisData?.gen_steps?.steps) {
      setAnalysisSteps(analysisData.gen_steps.steps.slice());
    }

    if (!analysisData?.gen_steps?.success) {
      setAnalysisSteps([]);
    }

    if (analysisData) {
      // set last existing stage
      if (!analysisBusy && stageDone) {
        setCurrentStage(analysisManager.currentStage);

        if (
          analysisManager.currentStage === "clarify" &&
          stageDone &&
          analysisData?.clarify?.clarification_questions?.length === 0
        ) {
          handleSubmit(null, { clarification_questions: [] }, "clarify");
        }
      }

      // if auto submit is on, and the current stage is null, submit for the first stage (aka clarify)
      if (initiateAutoSubmit && !analysisManager.currentStage) {
        handleSubmit();
      }
    }
  }, [analysisData, analysisBusy, stageDone]);

  function onMainSocketMessage(response) {
    const rType = response.request_type;
    const prop = propNames[rType];

    setAnalysisData(analysisManager.analysisData);
    setToolRunDataCache(analysisManager.toolRunDataCache);

    console.log(response);
    if (
      !response?.output ||
      !response?.output?.success ||
      !response?.output?.[prop]
    ) {
      setStageDone(true);
      setAnalysisBusy(false);
    }

    if (response.done) {
      setStageDone(true);
      setAnalysisBusy(false);
    }
  }

  async function onReRunMessage(response) {
    setRerunningSteps(analysisManager.reRunningSteps);
    // remove all pending updates for this tool_run_id
    // because all new data is already there in the received response
    setPendingToolRunUpdates((prev) => {
      const newUpdates = { ...prev };
      delete newUpdates[response.tool_run_id];
      return newUpdates;
    });

    setToolRunDataCache(analysisManager.toolRunDataCache);

    // update reactive context
    Object.keys(response?.tool_run_data?.outputs || {}).forEach((k, i) => {
      if (!response?.tool_run_data?.outputs?.[k]?.reactive_vars) return;
      const runId = response.tool_run_id;
      reactiveContext.update((prev) => {
        return {
          ...prev,
          [runId]: {
            ...prev[runId],
            [k]: response?.tool_run_data?.outputs?.[k]?.reactive_vars,
          },
        };
      });
    });

    setAnalysisSteps(analysisManager?.gen_steps?.steps || []);
  }

  const analysisManager = useMemo(() => {
    console.log("creating analysis manager");
    return AnalysisManager({
      analysisId,
      mainSocket: mainManager,
      rerunSocket: reRunManager,
      onNewData: onMainSocketMessage,
      onReRunData: onReRunMessage,
      username,
      userEmail: user,
      createAnalysisRequestBody,
    });
  }, [
    analysisId,
    mainManager,
    reRunManager,
    username,
    createAnalysisRequestBody,
  ]);

  useEffect(() => {
    async function initialiseAnalysis() {
      try {
        await analysisManager.init();

        setAnalysisData(analysisManager.analysisData);
        setAnalysisTitle(
          analysisManager?.analysisData?.user_question?.toUpperCase()
        );

        if (analysisManager.wasNewAnalysisCreated) {
          // also have to set docContext in this case
          docContext.update({
            ...docContext.val,
            userItems: {
              ...docContext.val.userItems,
              analyses: [
                ...docContext.val.userItems.analyses,
                analysisManager.analysisData,
              ],
            },
          });
        }
      } catch (e) {
        console.log(e);
      }
    }
    initialiseAnalysis();
  }, []);

  useEffect(() => {
    if (!analysisManager) return;

    analysisManager.setMainSocket(mainManager);
    analysisManager.setReRunSocket(reRunManager);

    analysisManager.addEventListeners();

    return () => {
      analysisManager.removeEventListeners();
    };
  }, [analysisManager, mainManager, reRunManager]);

  function handleSubmit(ev, stageInput = {}, submitSourceStage = null) {
    try {
      const query = searchRef.current.input.value;
      analysisManager.submit(ev, query, stageInput, submitSourceStage);

      // if everything went well above, prepare for receiving data for next stage
      setCurrentStage(analysisManager.nextStage);
      setStageDone(false);
      setAnalysisBusy(true);

      setAnalysisData(analysisManager.analysisData);

      setAnalysisTitle(query?.toUpperCase());

      return true;
    } catch (err) {
      console.log(err);
      setStageDone(false);
      setAnalysisBusy(false);
      // revert the next stage to the previous one
      setCurrentStage(analysisManager.currentStage);

      message.error(err);
      return false;
    }
  }

  const handleReRun = useCallback(
    (toolRunId, preRunActions = {}) => {
      if (
        !toolRunId ||
        !dag ||
        !analysisId ||
        !reRunManager ||
        !reRunManager.send ||
        !activeNode
      ) {
        console.log(toolRunId, dag, analysisId, reRunManager, activeNode);
        return;
      }

      try {
        analysisManager.initiateReRun(toolRunId, preRunActions);
        setAnalysisData(analysisManager.analysisData);
      } catch (e) {
        console.log(e);
        message.error(err);
      }
    },
    [analysisId, activeNode, reRunManager, dag, analysisManager]
  );

  console.log(analysisData, currentStage);

  return (
    <ErrorBoundary>
      <div className="analysis-agent-container">
        <ThemeContext.Provider
          value={{ theme: { type: "light", config: lightThemeColor } }}
          key="1"
        >
          {!analysisData ? (
            <div className="analysis-data-loader">
              <AgentLoader
                message={"Setting up..."}
                lottie={<Lottie animationData={LoadingLottie} loop={true} />}
              />
            </div>
          ) : (
            <div className="analysis-ctr">
              {currentStage === "clarify" && (
                <div className="analysis-recipe">
                  <Clarify
                    data={analysisData.clarify}
                    handleSubmit={handleSubmit}
                    globalLoading={analysisBusy}
                    stageDone={currentStage === "clarify" ? stageDone : true}
                    isCurrentStage={currentStage === "clarify"}
                  />
                </div>
              )}

              {currentStage === "gen_steps" && (
                <div className="analysis-content">
                  <div className="analysis-results">
                    <ErrorBoundary>
                      {analysisSteps.length ? (
                        <ToolResults
                          analysisId={analysisId}
                          activeNode={activeNode}
                          analysisData={analysisData}
                          toolSocketManager={toolSocketManager}
                          dag={dag}
                          setActiveNode={setActiveNode}
                          handleReRun={handleReRun}
                          reRunningSteps={reRunningSteps}
                          setPendingToolRunUpdates={setPendingToolRunUpdates}
                          toolRunDataCache={toolRunDataCache}
                          setToolRunDataCache={setToolRunDataCache}
                          setAnalysisData={setAnalysisData}
                        ></ToolResults>
                      ) : (
                        analysisBusy && (
                          <AgentLoader
                            message={"Running analysis..."}
                            lottie={
                              <Lottie
                                animationData={LoadingLottie}
                                loop={true}
                              />
                            }
                          />
                        )
                      )}
                    </ErrorBoundary>
                  </div>
                  <div className="analysis-steps">
                    <StepsDag
                      steps={analysisSteps}
                      nodeSize={[40, 10]}
                      nodeGap={[30, 50]}
                      setActiveNode={setActiveNode}
                      reRunningSteps={reRunningSteps}
                      activeNode={activeNode}
                      stageDone={
                        currentStage === "gen_steps" ? stageDone : true
                      }
                      dag={dag}
                      setDag={setDag}
                      dagLinks={dagLinks}
                      setDagLinks={setDagLinks}
                      extraNodeClasses={(node) => {
                        return node.data.isTool
                          ? `rounded-md px-1 text-center`
                          : "";
                      }}
                      toolIcon={(node) => (
                        <p className="text-sm truncate m-0">
                          {toolShortNames[node?.data?.step?.tool_name] ||
                            "Unknown tool"}
                        </p>
                      )}
                    />
                  </div>
                </div>
              )}
            </div>
          )}
        </ThemeContext.Provider>
      </div>
    </ErrorBoundary>
  );
};
