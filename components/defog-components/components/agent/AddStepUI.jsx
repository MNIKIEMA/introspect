import { Select } from "antd";
import { toolsMetadata } from "../../../../utils/tools_metadata";
import { useEffect, useMemo, useState } from "react";
import { AddStepInputList } from "./AddStepInputList";
import { ToolReRun } from "./ToolReRun";
import setupBaseUrl from "../../../../utils/setupBaseUrl";
import { v4 } from "uuid";

const toolOptions = Object.keys(toolsMetadata).map((tool) => {
  return { value: tool, label: toolsMetadata[tool]?.display_name };
});

const newStepToolRunEndpoint = setupBaseUrl("http", "new_step_tool_run");

export function AddStepUI({ analysisId, dag, activeNode }) {
  const [selectedTool, setSelectedTool] = useState(
    activeNode?.data?.meta?.tool_name
  );
  const [inputs, setInputs] = useState(activeNode?.data?.meta?.inputs || []);
  const [outputs, setOutputs] = useState(["output_" + v4().split("-")[0]]);

  const availableInputDfs = useMemo(() => {
    try {
      if (!activeNode || !activeNode.ancestors) return [];
      // only dfs generated by this node's ancestors are available
      const availableDfNodes = [...activeNode.ancestors()]
        .filter((d) => !d.data.isTool && d.data.id !== activeNode.data.id)
        .map((ancestor) => ancestor);

      return availableDfNodes;
    } catch (e) {
      console.log(e);
      return [];
    }
  }, [activeNode?.data?.id]);

  useEffect(() => {
    setSelectedTool(activeNode?.data?.meta?.tool_name);

    setInputs(activeNode?.data?.meta?.inputs || []);
  }, [activeNode?.data?.id]);

  return !activeNode ? (
    <>Something went wrong</>
  ) : (
    <div className="add-step-ctr">
      <h1 className="tool-name">New step</h1>
      <h1 className="inputs-header">TOOL</h1>
      <ToolReRun
        text="Run"
        onClick={async () => {
          console.log(
            activeNode.data.meta.parent_step,
            selectedTool,
            inputs,
            analysisId,
            outputs
          );

          try {
            const res = await fetch(newStepToolRunEndpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                parent_step: activeNode.data.meta.parent_step,
                tool_name: selectedTool,
                inputs: inputs,
                analysis_id: analysisId,
                outputs_storage_keys: outputs,
              }),
            }).then((r) => r.json());

            console.log(res);
          } catch (e) {
            console.log(e);
          }
        }}
      />
      <Select
        rootClassName="add-step-select-tool-name"
        options={toolOptions}
        value={selectedTool}
        onChange={(value) => {
          activeNode.data.meta.inputs = Array(
            toolsMetadata[value].function_signature.length
          ).fill(null);

          setInputs(activeNode.data.meta.inputs.slice());

          setSelectedTool(value);

          activeNode.data.meta.tool_name = value;
        }}
        placeholder="Select a tool"
      />
      {!selectedTool ? (
        <></>
      ) : (
        <>
          <h1 className="inputs-header">INPUTS</h1>
          <AddStepInputList
            toolRunId={activeNode.data.id}
            toolMetadata={toolsMetadata[selectedTool]}
            availableInputDfs={availableInputDfs}
            inputs={inputs}
            onEdit={(idx, prop, newVal) => {
              activeNode.data.meta.inputs[idx] = newVal;
              setInputs(activeNode.data.meta.inputs.slice());
            }}
          />
          <h1 className="inputs-header">OUTPUTS</h1>
          {/* a little kooky, but */}
          {/* just reuse AddStepInputList to store outputs */}
          <AddStepInputList
            toolRunId={activeNode.data.id}
            toolMetadata={{
              function_signature: [
                {
                  name: "output_names",
                  default: [],
                  type: "list",
                },
              ],
            }}
            newListValueDefault={() => "output_" + v4().split("-")[0]}
            availableInputDfs={availableInputDfs}
            inputs={[outputs]}
            onEdit={(idx, prop, newVal) => {
              console.log(idx, prop, newVal);
              // don't need to worry about idx, because it's always 0
              setOutputs(newVal);
            }}
          />
        </>
      )}
    </div>
  );
}
